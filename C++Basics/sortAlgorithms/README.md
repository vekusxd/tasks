# <center>Реализация различных методов сортировки в програмировании<center>

### **Bubble sort** (сортировка пузырьком)

- Пример реализации:
     ```cpp
    template<typename T>
        void bubbleSort(std::vector<T>& arr){
        for(int i = 0; i < arr.size() - 1; i++){
            for(int j = 0; j < arr.size() - 1 - i;j++){
                if(arr[j] > arr[j + 1]){
                    std::swap(arr[j], arr[j+1]);
                    }   
                }
            }
        }
     ```

- Характеристики(время работы, занимаемая память)
     
     | худшее |  средняя | лучшее |  память |
     | :----: |  :-----:| :--------: | :-------: |
     | O(n ^ 2) | O(n ^ 2) | O(n) | O(1)|

- Принцип работы:
     
     На каждом шаге алгоритма сравнивать 2 соседних числа, и в случае, если первое больше второго, менять их местами.

     Таким образом на каждом шаге алгоритма на свое место будет вставать одна цифра.

- Визуализация:
     ![bubble sort](https://www.resultswebdev.com/wp-content/themes/results-website-design/uploads/bubble-sort-animation2.gif)

- Преимущества:
  
     1. Простота в реализации и понимании
     2. Универсальность(работает для любых типов данных, поддерживающих операции сравнения)
     3. Неплохо работает на небольших данных
     4. Не требует допольнительной памяти
     5. Лучший случай O(n), если массив изначально отсортирован
   
- Недостатки:
  
     1. Время работы ощутимо на больших данных



### Selection sort (Сортировка выбором)

- Пример реализации:
     ```cpp
     template<typename T>
     void selectionSort(std::vector<T>& arr){
        for(int i = 0; i < arr.size() - 1; i++){
            int min = i;
            for(int j = i + 1; j < arr.size(); j++){
                if(arr[min] > arr[j]){
                    min = j;
                }
            }
        std::swap(arr[i], arr[min]);
        }
      }
     ```
     
- Характерстики (время работы, занимемая память):
     | худшее | среднее | лучшее | память |
     | :------: | :------:  | :-----: |  :------: |
     | O(n ^ 2) | O(n ^ 2)  | O(n ^ 2) | O(1)  |

- Принцип работы:
     На  каждом шаге алгоритма находить минимальный элемент в массиве и ставить его на место. Постепенно на каждом шаге получая по одному элементу.

- Визуализация
     ![selection sort](https://www.datasciencecentral.com/wp-content/uploads/2021/10/1wgCuMnGOINT5NCbg90Sxsw-1.gif)

- Примущества:
  
     1. Простота в понимании и реализации алгоритма
     2. Не требует допольнительной памяти
     3. Скорость работы на небольших данных не сильно влияет
     4. Универсальность

- Недостатки:
  
     1. Время работы всегда равняется O(n ^ 2)
   

- Примерное время работы в микросекундах:
  
     | Кол-во элементов   |  отcортированный массив | массив из случайных данных |
     | :-----------------:  |  :---------------------: | :------------------------:  |
     | 10           |       1        |          аналогично отсортированным |
     |   100        |       50 - 70       |        аналогично отсортированным                 |
     |  1000        |          около 4000    |     аналогично отсортированным          |



### Insertion sort (сортировка вставками)

- Пример реализации:
     
     ```cpp
    template<typename T>
    void insertionSort(std::vector<T>& arr){
        for(int i = 1; i < arr.size(); i++){
            int j = i - 1;
            T temp = arr[i];
            while(j >= 0 && arr[j] > temp){
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = temp;
        }
    }
     ```

- Характеристики (время работы, занимаемая память):
     | худшее | среднее | лучшее | память | 
     | :----: | :----: | :----: | :----: |
     | O(n ^ 2) | O(n ^ 2) | O(n ^ 2) | O(1) |

- Прицип работы:
  
  Начиная со второго элемента смотрим, есть ли слева элементы меньше. Если такие имеются, то мы сдвигаем элементы вправо, пока не найдем число меньшее текущего или не выйдем за предел массива. Это будет означать, что мы нашли место куда нужно "вставить" наш элемент.
  
  Таким образом на каждой итерации мы будет находить и сортировать массив по одному элементу, "вставляя" 'элемент на его место.

- Отличия от bubble и selection sort:
  
     В отличии от приведенных выше алгоритмов, insertion sort не совершает "бесполезных" операций сравнения, так если элементы стоят на своих местах изначально, алгоритму не будет нужно лишний раз проверять это и совершать лишние итерации.

     
     Это возможно рассмотреть на примере массива:

     arr  = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 32, 4, 5, 6, 7, 8, 543, 3, 12,34, 5, 6, 43, 1, 2, 3, 54, 5, 56, 7, 57, 7, 45, 35] 

     Первые 10 элементов которого изначально отсортированы

     Время в наносекундах:
     | Bubble | Selection | Insertion |
     | :----: | :-------: | :-------: |
     | 8000 - 9000 | 9000 - 1000 | 2000 - 3000|

     Как мы видим, insertion sort в среднем работает в 3 раза быстрее даже на таком небольшом наборе данных. Из этого можно сделать вывод, что insertion sort оптимальнее, чем его аналоги, хотя средний случай у всех трех сортировок равен O(n ^ 2)


- Визуализация:
     ![insertion sort](https://img2020.cnblogs.com/blog/2324401/202103/2324401-20210310204308654-45619857.gif)

- Примущества:
     1. Простота реализации и понимания
     2. Универсальность
     3. В случае, если массив частично отсортирован, алгоритм работает быстрее чем bubble и selection sort.
     4. Лучший случай O(n), если массив изначально отсортирован
     5. Не требует дополнительной памяти

- Недостатки:
     1. Средний случай O(n ^ 2), плохо работает на больших данных
  


### Counting sort (Сортировка подсчетом):

- Пример реализации:
     ```cpp
    void countingSort(std::vector<int>& arr){
        int max = *std::max_element(arr.begin(), arr.end());

        std::vector<int> temp(max + 1, 0);

        for(const int& n : arr){
            temp[n]++;
        }

        int j = 0;
        for(int i = 0; i < temp.size(); i++){
            while(temp[i] != 0){
                arr[j] = i;
                j++;
                temp[i]--;
            }
        }
    } 
     ```

- Характеристики (время работы, занимаемая память):
     | худшее | среднее | лучшее | память |
     |:-----: | :-----: | :----: | :----: |
     | O(n)   | O(n + m) | O(n + m) | O(m) |

     где m - количество возможных значений

- Принцип работы:

     Если набор данных представляет собой какое-то ограниченное множество, например числа от 0 до 100, то мы можем пройтись по всей коллекции и посчитать количество встречающихся элементов и записать их во вспомогательный массив, из которого потом мы сможем собрать отсортированную коллекцию.примеры использования сортировки подсчетом

     Изначально нужно создать массив, размера max_elem + 1, заполненного 0-ми. Затем пройтись по исходному массиву и записать в созданный для подсчета массив количество встречающихся чисел. Каждому числу будет соответсвовать свой индекс.

     После оcтается пройтись по полученному массиву и собрать данные в исходный массив.


- Сценарии использования сортировки подсчетом:
     
     Если заранее известно множество возможных значений, и оно не слишком велико, то сортировка подсчетом идеально подходит для сортировки подобных коллекций. Например массив записей прогноза погоды в городах за год, очевидно, что показатели термометров не могут быть больше 50 градусов или меньше 50, поэтому с помощью этого алгоритма мы сможем за линейное время обработать такую коллекцию, состоящую хоть из нескольких миллионов элементов, на которую даже лучшим универсальным алгоритмам сортировки ушло бы гораздо больше времени.

     В случае если множество представляет собой большой диапазон значений, то данная сортировка подходит не лучшим образом, так как в любом случае придется выделить в памяти  m + 1 размера массив, большинство элементов которого мы не используем.


- Визуализация:
  ![counting sort](https://thedukh.com/wp-content/uploads/2021/02/countingsort.gif)


- Преимущества:
     
     1. Скорость работы
     2. Простота в понимании
     
- Недостатки:
     
     1. Требуется дополнительное выделение памяти


### Radix sort (Цифровая сортировка)

- Пример реализации:
     ```cpp
     void radixSort(std::vector<int>& arr){
          std::vector<std::vector<int>> toCount(10);

          int max = *std::max_element(arr.begin(), arr.end());
          int rank = 1;
          while(max - rank >= 0){
               for(int& n : arr){
               int temp = n / rank;
               toCount[temp % 10].push_back(n);
          }

          int j = 0;
          for(auto &vector : toCount){
               while(!vector.empty()){
               int first = vector[0];
               vector.erase(vector.begin());
               arr[j] = first;
               j++;
               }
          }
          rank *= 10;
          }
     } 
     ```

- Принцип работы:
  
     Цифровая сортировка является сортировкой подсчета, адаптированной для  чисел. Ее суть такова, что мы применяем сортировку подсчета на разряды чисел. Что позволяет избежать главного минуса сортировки подсчета - изначального выделения массива размера m + 1, большинство значения которого мы возможно даже и не используем.

     Изначально нужно создать массив из 10 элементов(в моей реализации для удобства взят массив массивов), каждый элемент которого будет соответсвовать разряду числа.

     После пройтись по массиву столько раз, сколько всего разрядов имеется у самого большого числа в коллекции.

     И затем собрать получившийся массив.

     Несмотря на то, что алгоритм, кажется идеальным, он имеет существенный недостаток - он работает только для целых чисел.


- Характеристики(время работы, занимаемая память):
     |худшее | среднее | лучшее | память|
     |:----: | :-----: | :-----: | :----: |
     | O(n + m) | O(n * m) | O(n * m) | O(n + m)|

- Визуализация:
     ![radix sort](https://assets.digitalocean.com/articles/alligator/js/radix-sort/radix-sort-animation-o.gif)

- Особенности:
     
     Главной особенностью этого алгоритма сортировки является то, что он работает только с числами, но делает это очень хорошо. Поэтому идеально подходит для сортировки любых чисел в любом диапазоне(в отличии от сортировки подсчетом).

     сферы применения:
     
     1. Сортировка больших объемов данных в машином обучении и анализе данных
     2. Сортировка цифолвых изображений и звуковых файлов


- Преимущества:
  
     1. Время работы
     2. Подходит для любых диапазонов чисел
     3. Не тратит лишней памяти, в отличии от сортировки подсчетом
   
- Недостатки:
     1. Работает только с целыми числами
     
 

     
